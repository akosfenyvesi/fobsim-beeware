def genesis_block_generation():
    print("\nGenesis Block is generated. The Blockchain system is up...!")
    print("Miners will now collect transactions from memPool and start building blocks...\n\n")


def block_info(block, consensus_algorithm):
    print("The following block has been proposed by " + block['Header']['generator_id'] +
          " and is generated into the Blockchain network")
    print("**************************")
    print("transactions:")
    print(block['Body']['transactions'])
    print("hash:")
    print(block['Header']['hash'])
    print("timestamp:")
    print(block['Body']['timestamp'])
    if consensus_algorithm == 1:
        print("nonce:")
        print(block['Body']['nonce'])
    print("previous_hash:")
    print(block['Body']['previous_hash'])
    print("**************************")


def block_success_addition(self_address, generator_id):
    print("*******************************************")
    print("the block is now added to the local chain of " + self_address)
    if generator_id != self_address:
        print("this block was received from " + generator_id)
        print("##############################\n")


def simulation_progress(current_chain_length, expected_chain_length):
    # print("The simulation have passed " + str(100*((current_chain_length+1)/expected_chain_length)) + "% of TXs to miners")
    # print("Miners will mint new valid blocks and generate them to The BC network")
    pass


def fork_analysis(number_of_forks):
    if number_of_forks == 1:
        print("\n##############################\nThere were no forks during this run\n#############################\n")
    else:
        print("\n##############################\nAs the simulation is finished, " + str(number_of_forks) + " different versions of chains were found\n#############################\n")


def mempool_info(mempool):
    print('mempool contains the following TXs:')
    txs = []
    for i in range(mempool.qsize()):
        txs.append(mempool.get())
    for tx in txs:
        print(tx)
        mempool.put(tx)


def authorization_trigger(blockchain_placement, no_fogs, no_miners):
    print("please input the address of authorized:")
    if blockchain_placement == 1:
        print("Fog Nodes")
    else:
        print("End-users")
    print("to generate new blocks in the exact following format:")
    print(">>>> 1 OR 3 OR 50 ... (up to: ")
    if blockchain_placement == 1:
        print(str(no_fogs) + " fog nodes available")
    else:
        print(str(no_miners) + " miners available in the EU layer")
    print("Once done, kindly input: done")


def choose_functionality():
    print("Please choose the function of the Blockchain network:\n"
          "(1) Data Management\n"
          "(2) Computational services\n"
          "(3) Payment\n"
          "(4) Identity Management\n")


def choose_placement():
    print("Please choose the placement of the Blockchain network:\n"
          "(1) Fog Layer\n"
          "(2) End-User layer\n")


def choose_consensus(dict_of_consensus_algos):
    print("\nPlease choose the Consensus algorithm to be used in the simulation:\n")
    for key in dict_of_consensus_algos:
        print(key + ': ' + dict_of_consensus_algos[key])


def txs_success(txs_per_user, parent_add, self_add):
    print(str(txs_per_user) + " data records had been generated by End-User no. " + str(parent_add) + "." + str(self_add))


def GDPR_warning():
    print("###########################################"
          "\nWARNING: Each end-user's address and the address of the fog component it is connected with,\n "
          "will be immutably saved on the chain. This is not a GDPR-compliant practice.\n"
          "if you need to have your application GDPR-compliant, you need to change the configuration,\n"
          " so that other types of identities be saved on the immutable chain, and re-run the simulation."
          "\n###########################################\n")


def miners_are_up():
    print("*****************\nMiner nodes are up, connected to their neighbors, and waiting for the genesis block...!\n")


def illegal_tx(tx, wallet_content):
    print("the following transaction is illegal:")
    print(tx)
    print("the end_user_wallet contains only " + str(wallet_content) + " digital coins..!")
    print("the transaction is withdrawn from the block")


def illegal_block():
    print("The proposed block is not valid."
          "\nTransactions will be sent back to the mempool and mined again..!")


def unauthorized_miner_msg(miner_address):
    print("Miner: " + miner_address + " is not authorized to generate a new block..!")


def block_discarded():
    print("The received block was ignored because it is already in the local chain")


def users_and_fogs_are_up():
    print("*****************\nEnd_users are up\nFog nodes are up\nEnd-Users are connected to their Fog nodes...\n")


def user_identity_addition_reminder(Num_endusers):
    print("The network has " + str(Num_endusers) +
          " end_users.\n For each of them, you need to input the value of newly added identity "
          "attributes(if any)\n")


def local_chain_is_updated(miner_address, length_of_local_chain):
    print("Using the Gossip protocol of FoBSim, the local chain of the following miner was updated:")
    print("Miner: " + str(miner_address))
    print("The length of the new local chain: " + str(length_of_local_chain))


def mempool_is_empty():
    print("mempool is empty")


def finish():
    print("simulation is done.")
    print("To check/analyze the experiment, please refer to the temporary folder.")
    print("There, you can find:")
    print("- miners' local chains")
    print("- miners' local records of users' wallets")
    print("- log of blocks confirmed by the majority of miners")
    print("- log of final amounts in miners' wallets (initial values - staked values + awards)")
    print("- log of values which were staked by miners")
    print("thank YOU..!")

def main_orig():
    import Fog
    import end_user
    import miner
    import blockchain
    import random
    import output
    from math import ceil
    import time
    import modification
    import new_consensus_module

    data = modification.read_file("Sim_parameters.json")
    list_of_end_users = []
    fogNodes = []
    transactions_list = []
    list_of_authorized_miners = []
    blockchainFunction = 0
    blockchainPlacement = 0
    number_of_miner_neighbours = data["number_of_each_miner_neighbours"]
    NumOfFogNodes = data["NumOfFogNodes"]
    NumOfTaskPerUser = data["NumOfTaskPerUser"]
    NumOfMiners = data["NumOfMiners"]
    numOfTXperBlock = data["numOfTXperBlock"]
    num_of_users_per_fog_node = data["num_of_users_per_fog_node"]
    blockchain_functions = ['1', '2', '3', '4']
    blockchain_placement_options = ['1', '2']
    expected_chain_length = ceil((num_of_users_per_fog_node * NumOfTaskPerUser * NumOfFogNodes) / numOfTXperBlock)
    gossip_activated = data["Gossip_Activated"]
    Automatic_PoA_miners_authorization = data["Automatic_PoA_miners_authorization?"]
    Parallel_PoW_mining = data["Parallel_PoW_mining?"]
    trans_delay = 0
    delay_between_fog_nodes = data["delay_between_fog_nodes"]
    delay_between_end_users = data["delay_between_end_users"]
    poet_block_time = data['poet_block_time']
    Asymmetric_key_length = data['Asymmetric_key_length']
    number_of_DPoS_delegates = data['Num_of_DPoS_delegates']

    def user_input():
        modification.initiate_files(gossip_activated)
        choose_functionality()
        choose_placement()

    def choose_functionality():
        while True:
            output.choose_functionality()
            global blockchainFunction
            blockchainFunction = input()
            if blockchainFunction in blockchain_functions:
                blockchainFunction = int(blockchainFunction)
                break
            else:
                print("Input is incorrect, try again..!")

    def choose_placement():
        while True:
            output.choose_placement()
            global blockchainPlacement
            blockchainPlacement = input()
            if blockchainPlacement in blockchain_placement_options:
                blockchainPlacement = int(blockchainPlacement)
                break
            else:
                print("Input is incorrect, try again..!")

    def initiate_network():
        for count in range(NumOfFogNodes):
            fogNodes.append(Fog.Fog(count + 1))
            for p in range(num_of_users_per_fog_node):
                list_of_end_users.append(end_user.User(p + 1, count + 1))
        output.users_and_fogs_are_up()
        if blockchainFunction == 4:
            output.GDPR_warning()
            while True:
                print("If you don't want other attributes to be added to end_users, input: done\n")
                new_attribute = input("If you want other attributes to be added to end_users, input them next:\n")
                if new_attribute == 'done':
                    break
                else:
                    for user in list_of_end_users:
                        user.identity_added_attributes[new_attribute] = ''
                    output.user_identity_addition_reminder(len(list_of_end_users))
        for user in list_of_end_users:
            user.create_tasks(NumOfTaskPerUser, blockchainFunction, list_of_end_users)
            user.send_tasks(fogNodes)
            print("End_user " + str(user.addressParent) + "." + str(
                user.addressSelf) + " had sent its tasks to the fog layer")

    def initiate_miners():
        the_miners_list = []

        if blockchainPlacement == 1:
            for i in range(NumOfFogNodes):
                the_miners_list.append(miner.Miner(i + 1, trans_delay, gossip_activated))
        if blockchainPlacement == 2:
            for i in range(NumOfMiners):
                the_miners_list.append(miner.Miner(i + 1, trans_delay, gossip_activated))
        for entity in the_miners_list:
            modification.write_file("temporary/" + entity.address + "_local_chain.json", {})
            miner_wallets_log_py = modification.read_file("temporary/miner_wallets_log.json")
            miner_wallets_log_py[str(entity.address)] = data['miners_initial_wallet_value']
            modification.rewrite_file("temporary/miner_wallets_log.json", miner_wallets_log_py)
        print('Miners have been initiated..')
        connect_miners(the_miners_list)
        output.miners_are_up()
        return the_miners_list

    def define_trans_delay(layer):
        transmission_delay = 0
        if layer == 1:
            transmission_delay = delay_between_fog_nodes
        if layer == 2:
            transmission_delay = delay_between_end_users
        return transmission_delay

    def connect_miners(miners_list):
        print("Miners will be connected in a P2P fashion now. Hold on...")
        bridges = set()
        all_components = create_components(miners_list)
        for comp in all_components:
            bridge = random.choice(tuple(comp))
            bridges.add(bridge)
        bridging(bridges, miners_list)

    def bridging(bridges, miners_list):
        while len(bridges) != 1:
            bridge = random.choice(tuple(bridges))
            other_bridge = random.choice(tuple(bridges))
            same_bridge = True
            while same_bridge:
                other_bridge = random.choice(tuple(bridges))
                if other_bridge != bridge:
                    same_bridge = False
            for entity in miners_list:
                if entity.address == bridge:
                    entity.neighbours.add(other_bridge)
                if entity.address == other_bridge:
                    entity.neighbours.add(bridge)
            bridges.remove(bridge)

    def create_components(miners_list):
        all_components = set()
        for entity in miners_list:
            component = set()
            while len(entity.neighbours) < number_of_miner_neighbours:
                neighbour = random.choice(miners_list).address
                if neighbour != entity.address:
                    entity.neighbours.add(neighbour)
                    component.add(neighbour)
                    for entity_2 in miners_list:
                        if entity_2.address == neighbour:
                            entity_2.neighbours.add(entity.address)
                            component.add(entity.address)
                            break
            if component:
                all_components.add(tuple(component))
        return all_components

    def give_miners_authorization(the_miners_list, the_type_of_consensus):
        if the_type_of_consensus == 3:
            # automated approach:
            if Automatic_PoA_miners_authorization:
                for i in range(len(the_miners_list)):
                    the_miners_list[i].isAuthorized = True
                    list_of_authorized_miners.append(the_miners_list[i])
            else:
                # user input approach:
                output.authorization_trigger(blockchainPlacement, NumOfFogNodes, NumOfMiners)
                while True:
                    authorized_miner = input()
                    if authorized_miner == "done":
                        break
                    else:
                        for node in the_miners_list:
                            if node.address == "Miner_" + authorized_miner:
                                node.isAuthorized = True
                                list_of_authorized_miners.append(node)

    def initiate_genesis_block():
        genesis_transactions = ["genesis_block"]
        for i in range(len(miner_list)):
            genesis_transactions.append(miner_list[i].address)
        genesis_block = new_consensus_module.generate_new_block(genesis_transactions, 'The Network', 0,
                                                                type_of_consensus)
        output.block_info(genesis_block, type_of_consensus)
        for elem in miner_list:
            elem.receive_new_block(genesis_block, type_of_consensus, miner_list, blockchainFunction,
                                   expected_chain_length)
        output.genesis_block_generation()

    def send_tasks_to_BC():
        for node in fogNodes:
            node.send_tasks_to_BC()

    def inform_miners_of_users_wallets():
        if blockchainFunction == 3:
            user_wallets = {}
            for user in list_of_end_users:
                wallet_info = {'parent': user.addressParent,
                               'self': user.addressSelf,
                               'wallet_value': user.wallet}
                user_wallets[str(user.addressParent) + '.' + str(user.addressSelf)] = wallet_info
            for i in range(len(miner_list)):
                modification.rewrite_file(str("temporary/" + miner_list[i].address + "_users_wallets.json"),
                                          user_wallets)

    if __name__ == '__main__':
        user_input()
        initiate_network()
        type_of_consensus = new_consensus_module.choose_consensus()
        trans_delay = define_trans_delay(blockchainPlacement)
        miner_list = initiate_miners()
        give_miners_authorization(miner_list, type_of_consensus)
        inform_miners_of_users_wallets()
        blockchain.stake(miner_list, type_of_consensus)
        initiate_genesis_block()
        send_tasks_to_BC()
        time_start = time.time()
        if blockchainFunction == 2:
            expected_chain_length = ceil((num_of_users_per_fog_node * NumOfTaskPerUser * NumOfFogNodes))
        new_consensus_module.miners_trigger(miner_list, type_of_consensus, expected_chain_length, Parallel_PoW_mining,
                                            numOfTXperBlock, blockchainFunction, poet_block_time, Asymmetric_key_length,
                                            number_of_DPoS_delegates)

        blockchain.award_winning_miners(len(miner_list))
        blockchain.fork_analysis(miner_list)
        output.finish()
        elapsed_time = time.time() - time_start
        print("elapsed time = " + str(elapsed_time) + " seconds")

import Fog
import end_user
import miner
import blockchain
import random
import output
from math import ceil
import time
import modification
import new_consensus_module


data = modification.read_file("Sim_parameters.json")
list_of_end_users = []
fogNodes = []
transactions_list = []
list_of_authorized_miners = []
blockchainFunction = 0
blockchainPlacement = 0
number_of_miner_neighbours = data["number_of_each_miner_neighbours"]
NumOfFogNodes = data["NumOfFogNodes"]
NumOfTaskPerUser = data["NumOfTaskPerUser"]
NumOfMiners = data["NumOfMiners"]
numOfTXperBlock = data["numOfTXperBlock"]
num_of_users_per_fog_node = data["num_of_users_per_fog_node"]
blockchain_functions = ['1', '2', '3', '4']
blockchain_placement_options = ['1', '2']
expected_chain_length = ceil((num_of_users_per_fog_node * NumOfTaskPerUser * NumOfFogNodes) / numOfTXperBlock)
gossip_activated = data["Gossip_Activated"]
Automatic_PoA_miners_authorization = data["Automatic_PoA_miners_authorization?"]
Parallel_PoW_mining = data["Parallel_PoW_mining?"]
trans_delay = 0
delay_between_fog_nodes = data["delay_between_fog_nodes"]
delay_between_end_users = data["delay_between_end_users"]
poet_block_time = data['poet_block_time']
Asymmetric_key_length = data['Asymmetric_key_length']
number_of_DPoS_delegates = data['Num_of_DPoS_delegates']


def user_input():
    modification.initiate_files(gossip_activated)
    choose_functionality()
    choose_placement()


def choose_functionality():
    while True:
        output.choose_functionality()
        global blockchainFunction
        blockchainFunction = input()
        if blockchainFunction in blockchain_functions:
            blockchainFunction = int(blockchainFunction)
            break
        else:
            print("Input is incorrect, try again..!")


def choose_placement():
    while True:
        output.choose_placement()
        global blockchainPlacement
        blockchainPlacement = input()
        if blockchainPlacement in blockchain_placement_options:
            blockchainPlacement = int(blockchainPlacement)
            break
        else:
            print("Input is incorrect, try again..!")


def initiate_network():
    for count in range(NumOfFogNodes):
        fogNodes.append(Fog.Fog(count + 1))
        for p in range(num_of_users_per_fog_node):
            list_of_end_users.append(end_user.User(p + 1, count + 1))
    output.users_and_fogs_are_up()
    if blockchainFunction == 4:
        output.GDPR_warning()
        while True:
            print("If you don't want other attributes to be added to end_users, input: done\n")
            new_attribute = input("If you want other attributes to be added to end_users, input them next:\n")
            if new_attribute == 'done':
                break
            else:
                for user in list_of_end_users:
                    user.identity_added_attributes[new_attribute] = ''
                output.user_identity_addition_reminder(len(list_of_end_users))
    for user in list_of_end_users:
        user.create_tasks(NumOfTaskPerUser, blockchainFunction, list_of_end_users)
        user.send_tasks(fogNodes)
        print("End_user " + str(user.addressParent) + "." + str(user.addressSelf) + " had sent its tasks to the fog layer")


def initiate_miners():
    the_miners_list = []

    if blockchainPlacement == 1:
        for i in range(NumOfFogNodes):
            the_miners_list.append(miner.Miner(i + 1, trans_delay, gossip_activated))
    if blockchainPlacement == 2:
        for i in range(NumOfMiners):
            the_miners_list.append(miner.Miner(i + 1, trans_delay, gossip_activated))
    for entity in the_miners_list:
        modification.write_file("temporary/" + entity.address + "_local_chain.json", {})
        miner_wallets_log_py = modification.read_file("temporary/miner_wallets_log.json")
        miner_wallets_log_py[str(entity.address)] = data['miners_initial_wallet_value']
        modification.rewrite_file("temporary/miner_wallets_log.json", miner_wallets_log_py)
    print('Miners have been initiated..')
    connect_miners(the_miners_list)
    output.miners_are_up()
    return the_miners_list


def define_trans_delay(layer):
    transmission_delay = 0
    if layer == 1:
        transmission_delay = delay_between_fog_nodes
    if layer == 2:
        transmission_delay = delay_between_end_users
    return transmission_delay


def connect_miners(miners_list):
    print("Miners will be connected in a P2P fashion now. Hold on...")
    bridges = set()
    all_components = create_components(miners_list)
    for comp in all_components:
        bridge = random.choice(tuple(comp))
        bridges.add(bridge)
    bridging(bridges, miners_list)


def bridging(bridges, miners_list):
    while len(bridges) != 1:
        bridge = random.choice(tuple(bridges))
        other_bridge = random.choice(tuple(bridges))
        same_bridge = True
        while same_bridge:
            other_bridge = random.choice(tuple(bridges))
            if other_bridge != bridge:
                same_bridge = False
        for entity in miners_list:
            if entity.address == bridge:
                entity.neighbours.add(other_bridge)
            if entity.address == other_bridge:
                entity.neighbours.add(bridge)
        bridges.remove(bridge)


def create_components(miners_list):
    all_components = set()
    for entity in miners_list:
        component = set()
        while len(entity.neighbours) < number_of_miner_neighbours:
            neighbour = random.choice(miners_list).address
            if neighbour != entity.address:
                entity.neighbours.add(neighbour)
                component.add(neighbour)
                for entity_2 in miners_list:
                    if entity_2.address == neighbour:
                        entity_2.neighbours.add(entity.address)
                        component.add(entity.address)
                        break
        if component:
            all_components.add(tuple(component))
    return all_components


def give_miners_authorization(the_miners_list, the_type_of_consensus):
    if the_type_of_consensus == 3:
        # automated approach:
        if Automatic_PoA_miners_authorization:
            for i in range(len(the_miners_list)):
                the_miners_list[i].isAuthorized = True
                list_of_authorized_miners.append(the_miners_list[i])
        else:
            # user input approach:
            output.authorization_trigger(blockchainPlacement, NumOfFogNodes, NumOfMiners)
            while True:
                authorized_miner = input()
                if authorized_miner == "done":
                    break
                else:
                    for node in the_miners_list:
                        if node.address == "Miner_" + authorized_miner:
                            node.isAuthorized = True
                            list_of_authorized_miners.append(node)


def initiate_genesis_block():
    genesis_transactions = ["genesis_block"]
    for i in range(len(miner_list)):
        genesis_transactions.append(miner_list[i].address)
    genesis_block = new_consensus_module.generate_new_block(genesis_transactions, 'The Network', 0, type_of_consensus)
    output.block_info(genesis_block, type_of_consensus)
    for elem in miner_list:
        elem.receive_new_block(genesis_block, type_of_consensus, miner_list, blockchainFunction, expected_chain_length)
    output.genesis_block_generation()


def send_tasks_to_BC():
    for node in fogNodes:
        node.send_tasks_to_BC()


def inform_miners_of_users_wallets():
    if blockchainFunction == 3:
        user_wallets = {}
        for user in list_of_end_users:
            wallet_info = {'parent': user.addressParent,
                           'self': user.addressSelf,
                           'wallet_value': user.wallet}
            user_wallets[str(user.addressParent) + '.' + str(user.addressSelf)] = wallet_info
        for i in range(len(miner_list)):
            modification.rewrite_file(str("temporary/" + miner_list[i].address + "_users_wallets.json"), user_wallets)


def main_function():
    user_input()
    initiate_network()
    type_of_consensus = new_consensus_module.choose_consensus()
    trans_delay = define_trans_delay(blockchainPlacement)
    miner_list = initiate_miners()
    give_miners_authorization(miner_list, type_of_consensus)
    inform_miners_of_users_wallets()
    blockchain.stake(miner_list, type_of_consensus)
    initiate_genesis_block()
    send_tasks_to_BC()
    time_start = time.time()
    if blockchainFunction == 2:
        expected_chain_length = ceil((num_of_users_per_fog_node * NumOfTaskPerUser * NumOfFogNodes))
    new_consensus_module.miners_trigger(miner_list, type_of_consensus, expected_chain_length, Parallel_PoW_mining,
                                        numOfTXperBlock, blockchainFunction, poet_block_time, Asymmetric_key_length,
                                        number_of_DPoS_delegates)

    blockchain.award_winning_miners(len(miner_list))
    blockchain.fork_analysis(miner_list)
    output.finish()
    elapsed_time = time.time() - time_start
    print("elapsed time = " + str(elapsed_time) + " seconds")

